from collections import deque

GOAL_STATE =  ((1,2,3),
              (8, 0, 4),
              (7, 6, 5))

MOVES = {
    'UP': (-1, 0),
    'DOWN': (1, 0),
    'LEFT': (0, -1),
    'RIGHT': (0, 1)
}

def find_zero(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def is_valid_pos(x, y):
    return 0 <= x < 3 and 0 <= y < 3

def swap_positions(state, pos1, pos2):
    state_list = [list(row) for row in state]
    x1, y1 = pos1
    x2, y2 = pos2
    state_list[x1][y1], state_list[x2][y2] = state_list[x2][y2], state_list[x1][y1]
    return tuple(tuple(row) for row in state_list)

def get_neighbors(state):
    neighbors = []
    x, y = find_zero(state)
    for move in MOVES.values():
        new_x, new_y = x + move[0], y + move[1]
        if is_valid_pos(new_x, new_y):
            neighbors.append(swap_positions(state, (x, y), (new_x, new_y)))
    return neighbors

def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    path.reverse()
    return path

def bfs(start_state):
    queue = deque([start_state])
    visited = set([start_state])
    came_from = {}

    while queue:
        current = queue.popleft()
        if current == GOAL_STATE:
            return reconstruct_path(came_from, current)
        for neighbor in get_neighbors(current):
            if neighbor not in visited:
                visited.add(neighbor)
                came_from[neighbor] = current
                queue.append(neighbor)
    return None

def print_state(state):
    for row in state:
        print(' '.join(str(x) if x != 0 else '_' for x in row))
    print()

if __name__ == "__main__":
    start_state = ((2, 8, 3),
                   (1, 6, 4),
                   (7,0,5))

    print("Initial State:")
    print_state(start_state)

    print("Solving with BFS...")
    bfs_path = bfs(start_state)
    if bfs_path:
        print(f"Solution found in {len(bfs_path) - 1} moves!")
        for state in bfs_path:
            print_state(state)
    else:
        print("No solution found with BFS.")
