def calculate_conflicts(board):
    conflicts = 0
    n = len(board)
    for i in range(n):
        for j in range(i + 1, n):
            if board[i] == board[j] or abs(board[i] - board[j]) == j - i:
                conflicts += 1
    return conflicts

def print_board(board):
    n = len(board)
    for row in range(n):
        line = ['Q' if col == board[row] else '.' for col in range(n)]
        print(' '.join(line))
    print()

def hill_climbing_step_by_step(board):
    n = len(board)
    current_state = board[:]
    current_conflicts = calculate_conflicts(current_state)
    
    step = 0
    print("Name:Umesha H N\nUSN:1BM24CS428\n")
    print(f"Initial board with conflicts = {current_conflicts}:")
    print_board(current_state)
    
    while current_conflicts > 0:
        step += 1
        print(f"Step {step}:")
        best_state = current_state[:]
        best_conflicts = current_conflicts
        
        for row in range(n):
            original_col = current_state[row]
            for col in range(n):
                if col != original_col:
                    current_state[row] = col
                    conflicts = calculate_conflicts(current_state)
                    
                    if conflicts < best_conflicts:
                        best_conflicts = conflicts
                        best_state = current_state[:]
            
            current_state[row] = original_col
        
        if best_conflicts == current_conflicts:
            print("No better neighbor found, stuck at local optimum.")
            break
        
        current_state = best_state
        current_conflicts = best_conflicts
        
        print(f"Board with conflicts = {current_conflicts}:")
        print_board(current_state)
    
    if current_conflicts == 0:
        print("Solution found!")
    else:
        print("No solution found.")
    return current_state

initial_board = [3, 0, 1, 2]
solution = hill_climbing_step_by_step(initial_board)
